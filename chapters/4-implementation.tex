\chapter{Implementation}

In this thesis I aim to create an LSM-structured implementation of R-trees, which in turn will be write-optimized. To be able to handle a high workload of write operations without compromising query performance, a bulk-insertion technique such as GBI\cite{GBI} or Seeded Clustering\cite{SeededClustering} will be used to make sure that the index structure is not degraded too much. In addition, the use of such techniques will hopefully also generate better storage utilisation which is needed to avoid unnecessary search operations. I have chosen to call my implementation a \emph{Rectangle-Structured Merge Tree} or RSM-Tree.

\section{Overview}
In order to implement an R-tree index while having a LSM-tree structure, there are some important design choices that need to be evaluated. The first is the ordering of the data, as R-trees are used for multi-dimensional data, while LSM-trees are not. In order to do this, the use of space-filling curves are needed, such as Z-order curve or Hilbert curve. In my implementation, the main ordering technique will be Z-order curve, but both curves might be tested. Another important aspect is how to merge the data from the upper levels to the lower levels. To do this I have chosen to use bulk-insertion methods which looks at loading smaller R-trees into larger ones. By doing this, the costly operation of creating R-trees from scratch will not be needed with every merge.\newline

Lastly, the choice of merge policies is important. As inspired from Dostoevsky\cite{Dostoevsky}, I will try different combinations of tiering and leveling policies as explained in Section \ref{Dostoevsky}. This is done in order to tune the write and search performance as needed.  

\section{Structure}
The general structure of the RSM-tree is presented in Figure \ref{fig:RSMTree}. The in-memory component $C_0$ stores each data object in their own MBR, given as $A, B, ..., F$. These are sequentially ordered following the chosen space-filling curve. This is done because it is crucial that the items are sequentially ordered when performing search operations in LSM-trees. In addition to this, a sequential structure is beneficial when merging the data to the lower levels, as will be further explained in Section \ref{sect:RSM-Merging}. In the second level $C_1$, the MBRs will be merged together to create R-trees from scratch, given as $R_2, R_3, R_4, R_5$. The lowest level $C_2$, is structured as the main R-tree, where trees from $C_2$ will be bulk-inserted into the correct positions in the main R-tree.  
\begin{figure}[ht]
     \centering
     \begin{subfigure}{0.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/RSMTree.pdf}
         \caption{RSM-Tree index structure}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{figures/RSMTree_space.pdf}
         \caption{RSM-Tree space structure}
     \end{subfigure}
        \caption{RSM-Tree}
        \label{fig:RSMTree}
\end{figure}

The nodes in the RSM-tree are structured as shown in Figure \ref{fig:nodeRSM}. The first value is the Z-order value calculated from the objects minimum bounding rectangle (MBR), while the MBR is the rectangle containing the object. The last element \emph{pointer}, points to either an intermediate node's children nodes or an object identifier. The calculation of the z-order values is explained in Section \ref{sect:zordering}. 

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{figures/node_RSM.pdf}
    \caption{RSM-Tree Node structure}
    \label{fig:nodeRSM}
\end{figure}

\section{Space-Filling Curve}
\label{sect:ordering}
The use of a space-filling curve in order to create the RSM-tree is crucial in order to sequentially order the objects in level $C_0$. As Z-ordering is simpler to implement, as well as being less costly, it will be the implemented technique. This is also because it has proven to perform well with a low number of dimensions\cite{IrregularSpace}, which will be the case when inserting test data. When further developing the RSM-tree, it is also possible to implement the Hilbert curve ordering technique, but this will not be a priority during the first implementation. 

\subsection{Z-ordering}
\label{sect:zordering}
To calculate the Z-values of each object, the $x$ and $y$ coordinates of the object's MBR is found. These coordinates can be chosen as the outer corner of a rectangle or as the rectangle's center. In my implementation, the coordinates will be calculated from the center. These coordinates will then be represented as their binary value. In order to calculate the binary representation of the two coordinates together, their individual values are interleaved (\textbf{må kanskje finne en referanse her)}. An example of this process is shown in Figure \ref{fig:bitInterleaving}. \textbf{forklar mer om hva som skjer i bildet.}


\section{Merging}
\label{sect:RSM-Merging}
The merging technqiue for the RSM-tree is based on both construction of R-trees from scratch, in addition to using bulk-insertion into existing trees. From the in-memory component $C_0$, a portion of $N$ objects are taken at a time to create an R-tree from scratch. This R-tree is then stored at the lower level $C_2$. $N$ is chosen to be a number so that $n$ nodes can be filled with a with a capacity greater than $m$ and smaller than $M$, where $m$ is the minimum number of objects in a node and $M$ is the maximum number of objects. This is done to gurantee that the R-tree structure is valid by avoiding situations where node underflow occurs while still leaving room for additional objects when further merging is done to the lower level. As the objects in $C_0$ are already sequentially ordered by their placements, the trees in $C_1$ are also possible to order. In the optimal scenario, the R-trees in $C_1$ will have no overlap with each other. This can be verified by looking at the overlap between their root nodes. As this might be hard to guarantee in a real-life scenario, this is a challenge that needs to be further investigated when the implementation is created.  \textbf{kanskje noe mer her om hvordan dette skal håndteres, sjekk med SE} \newline

The merging from $C_1$ to the lowest component $C_2$ is done by having an existing R-tree index in the lowest level. When data is ready to be merged from $C_1$, a whole R-tree is bulk-inserted into the main R-tree in $C_3$.

\textbf{Her må det inne noe om hvilken bulk-insertion metode du skal bruke og hvorfor..}

\textbf{Må snakke om potensiell overlapp av MBRs! Hvordan håndtere dette? Burde du ha firkantede MBRs? Se på R*-tree}

\subsection{Merge policies}
\textbf{Skriv noe om de forskjellige variantene du kan prøve ut, hva som er hovedkonseptet...}