\chapter{Related Work}

\section{Dostoevsky}
\label{Dostoevsky}
An optimization of LSM-trees was introduced in 2018 by Niv Dayan and Stratos Idreos. Their research introduces a concept called \emph{Dostoevsky}, in full \emph{Space-Time Optimized Evolvable Scalable Key-Value store}\cite{Dostoevsky}. The solution consists of taking advantage of the different merge policies \emph{tiering} and \emph{leveling} to find the best trade-off between update costs and lookup costs. An important find in their research is that by only conducting merge operations on the largest level, the update cost is improved without affecting lookup or storage costs to an important extent. As updates in LSM-trees are executed by sending it down through the levels, old entries in the largest level are outdated and takes up unnecessary space. In addition, all entries will be merged in every level since outdated entries are not removed until its updated value reaches the largest level.\newline 

To take advantage of these characteristics, a design solution called \emph{Lazy Leveling} is introduced. Lazy Leveling is designed so that only the largest level conducts any merge operations, while all levels above consists of a tiering merge policy. By having this implementation the cost of merging entries at each level is avoided, which in turn reduces the update cost. To be able to tune the design of the LSM-tree, Lazy Leveling is incorporated in another design solution called \emph{Fluid LSM-tree}. In this approach, the largest level is also separated from the smaller ones. This is done by assigning a maximum run size of $Z$ to the largest level, while a maximum run size of $K$ is given to the levels above. To accommodate these sizes, each level also have an \emph{active run} with a size threshold of $T/K$ or $T/Z$ for the smaller and largest levels respectively. $T$ is set to be the ratio between adjacent levels. When these active runs reaches their threshold, their runs are merged into the lower level's active run. The use of Lazy Leveling in the Fluid LSM-tree comes into effect when setting the parameters $K=T-1$ and $Z = 1$. If both parameters are set to $T-1$, the LSM-tree has a tiering merge policy. With parameters set to $1$, the merge policy chosen is leveling. \newline

In order to tune the Fluid LSM-tree correctly according to the application area, the tuning parameters are set while having a constraint on space amplification. The goal is to optimize throughput by looking at update cost, zero-result point lookup cost, non-zero result point lookup cost and range lookup cost. Each of these values are weighted and multiplied by the time it takes to read a block from storage. In order to check the worst-case scenario, the different values are found by setting different parameters for $T$, $Z$ and $K$. The calculation is then iterated. The automatic way of finding the best settings for the parameters, as explained above, is called Dostoevsky. This solution is shown to have much better results than existing solutions such as RocksDB\cite{Dostoevsky}. This is due to the fact that RocksDB only uses leveling, while Dostoevsky is able to change the merge policy of its levels in-between workloads. 